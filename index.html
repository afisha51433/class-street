<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ç­ç´šå°è¡—é“ 3D å±•ç¤ºï¼ˆæ‹–æ‹‰ä¸Šå‚³ GLBï¼‰</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", "PingFang TC", "Microsoft JhengHei", sans-serif; }
    #app { position: absolute; inset: 0; display: grid; grid-template-columns: 320px 1fr; }
    #sidebar { background: #0f172a; color: #e2e8f0; padding: 16px; overflow: auto; }
    #sidebar h1 { font-size: 18px; margin: 0 0 8px; }
    #sidebar p { font-size: 13px; line-height: 1.5; color: #cbd5e1; }
    #sidebar .dropzone { border: 2px dashed #64748b; border-radius: 12px; padding: 16px; text-align: center; background: #111827; color: #cbd5e1; cursor: pointer; }
    #sidebar .dropzone.dragover { border-color: #93c5fd; background: #0b1220; }
    #file { display: none; }
    #list { margin-top: 12px; font-size: 13px; }
    #list .item { display: flex; align-items: center; gap: 8px; padding: 6px 8px; border-radius: 8px; background: #0b1220; margin-bottom: 6px; }
    #list .badge { background: #1e293b; color: #93c5fd; border: 1px solid #334155; padding: 2px 6px; border-radius: 999px; font-size: 11px; }
    #controls { display: grid; gap: 8px; margin-top: 12px; }
    button { appearance: none; border: 1px solid #334155; background: #0b1220; color: #e2e8f0; padding: 8px 10px; border-radius: 10px; cursor: pointer; font-weight: 600; }
    button:hover { background: #111827; }
    #help { font-size: 12px; color: #94a3b8; margin-top: 8px; }
    #canvas-wrap { position: relative; background: #0b1020; }
    #hint { position: absolute; top: 12px; left: 12px; background: rgba(15,23,42,0.7); color: #e2e8f0; padding: 8px 10px; border-radius: 8px; font-size: 12px; pointer-events: none; }
  </style>
</head>
<body>
  <div id="app">
    <aside id="sidebar">
      <h1>ç­ç´šå°è¡—é“ 3D å±•ç¤º</h1>
      <p>æŠŠåšå¥½çš„ <b>.glb</b>ï¼ˆå»ºè­°ï¼‰æˆ– <b>.obj .stlf</b> æª”æ¡ˆæ‹–æ›³åˆ°ä¸‹é¢çš„æ¡†ï¼Œæˆ–é»æ“Šä¸Šå‚³ã€‚ç³»çµ±æœƒè‡ªå‹•æŠŠæ¯æ£Ÿæˆ¿å­ä¾åºæ’åœ¨è¡—é“ä¸Šã€‚<br/>ï¼ˆåƒ…æœ¬æ©Ÿç€è¦½ï¼Œæª”æ¡ˆä¸æœƒä¸Šå‚³åˆ°ç¶²è·¯ï¼‰</p>
      <div class="dropzone" id="dropzone" tabindex="0" role="button" aria-label="æ‹–æ”¾æˆ–é»æ“Šé¸æ“‡æª”æ¡ˆ">
        æ‹–æ”¾æª”æ¡ˆåˆ°é€™è£¡ï¼Œæˆ–é»æˆ‘é¸æ“‡
        <input id="file" type="file" accept=".glb,.gltf,.zip" multiple />
      </div>
      <div id="controls">
        <button id="resetCam">é‡è¨­è¦–è§’</button>
        <button id="clearAll">æ¸…é™¤å…¨éƒ¨æ¨¡å‹</button>
      </div>
      <div id="help">ğŸ’¡ å°æ’‡æ­¥ï¼šå»ºè­°åŒ¯å‡º <b>GLB</b>ï¼Œå¤§å°æ§åˆ¶åœ¨ 5â€“20MB å…§ï¼›æª”åå³ç‚ºæˆ¿å­æ¨™ç±¤ã€‚</div>
      <div id="list"></div>
    </aside>
    <main id="canvas-wrap">
      <div id="hint">æ»‘é¼ æ‹–æ›³æ—‹è½‰ã€æ»¾è¼ªç¸®æ”¾ã€å³éµå¹³ç§»ã€‚ä¹Ÿå¯æŠŠæª”æ¡ˆç›´æ¥æ‹–é€²è¦–çª—ã€‚</div>
      <canvas id="c"></canvas>
    </main>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.161.0/examples/jsm/loaders/GLTFLoader.js';
    import { OBJLoader } from 'https://unpkg.com/three@0.161.0/examples/jsm/loaders/OBJLoader.js';
    import { STLLoader } from 'https://unpkg.com/three@0.161.0/examples/jsm/loaders/STLLoader.js';

    // --- Three.js åŸºæœ¬å ´æ™¯è¨­å®š ---
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87a6d1); // æŸ”å’Œå¤©ç©ºè‰²

    const camera = new THREE.PerspectiveCamera(60, 2, 0.1, 2000);
    camera.position.set(24, 16, 34);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(10, 0, 0);

    // å…‰æº
    const hemi = new THREE.HemisphereLight(0xffffff, 0x445566, 0.7);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(10, 30, 12);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048, 2048);
    scene.add(dir);

    // åœ°é¢èˆ‡è¡—é“
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(400, 200),
      new THREE.MeshPhongMaterial({ color: 0xa3c3a1, depthWrite: true })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // è·¯é¢ï¼ˆæ·±ç°ï¼‰
    const roadWidth = 16;
    const roadLength = 360;
    const road = new THREE.Mesh(
      new THREE.BoxGeometry(roadLength, 0.1, roadWidth),
      new THREE.MeshStandardMaterial({ color: 0x2a2f36 })
    );
    road.position.set(roadLength/2 - 20, 0.05, 0);
    road.receiveShadow = true;
    scene.add(road);

    // äººè¡Œé“ï¼ˆå…©å´æ·ºç°ï¼‰
    const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0xbfc5cc });
    const sidewalkLeft = new THREE.Mesh(new THREE.BoxGeometry(roadLength, 0.2, 3), sidewalkMat);
    sidewalkLeft.position.set(road.position.x, 0.11, -roadWidth/2 - 1.5);
    sidewalkLeft.receiveShadow = true;
    scene.add(sidewalkLeft);

    const sidewalkRight = sidewalkLeft.clone();
    sidewalkRight.position.z = roadWidth/2 + 1.5;
    scene.add(sidewalkRight);

    // ä¸­ç·šï¼ˆè™›ç·šï¼‰
    const dashes = new THREE.Group();
    const dashGeom = new THREE.BoxGeometry(3, 0.05, 0.3);
    const dashMat = new THREE.MeshStandardMaterial({ color: 0xf3f4f6 });
    for (let x = 0; x < roadLength; x += 6) {
      const dash = new THREE.Mesh(dashGeom, dashMat);
      dash.position.set(x - 20, 0.06, 0);
      dashes.add(dash);
    }
    scene.add(dashes);

    // ç°¡å–®ç’°å¢ƒï¼šæ¨¹ï¼ˆè£é£¾ï¼‰
    function addTree(x, z) {
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 3, 8), new THREE.MeshStandardMaterial({ color: 0x8b5a2b }));
      trunk.castShadow = true; trunk.receiveShadow = true;
      trunk.position.set(x, 1.5, z);

      const crown = new THREE.Mesh(new THREE.SphereGeometry(1.4, 16, 12), new THREE.MeshStandardMaterial({ color: 0x2f855a }));
      crown.castShadow = true; crown.receiveShadow = true;
      crown.position.set(x, 3.3, z);

      scene.add(trunk, crown);
    }
    for (let i = 0; i < 18; i++) {
      addTree(i * 18 - 6, -roadWidth/2 - 5);
      addTree(i * 18 - 2, roadWidth/2 + 6);
    }

    // GLTF/OBJ/STL è¼‰å…¥èˆ‡æ’ç‰ˆ
    const gltfLoader = new GLTFLoader();
    const objLoader = new OBJLoader();
    const stlLoader = new STLLoader();
    const models = []; // { name, obj }

    const targetSize = 6; // ç›®æ¨™æœ€å¤§é‚Šé•·ï¼Œè®“æ¯æ£Ÿæˆ¿å­å¤§å°ä¸€è‡´
    const spacing = 10; // æˆ¿å­ä¹‹é–“çš„é–“è·ï¼ˆæ²¿ X æ–¹å‘æ’ï¼‰
    let houseCount = 0;

    function placeModel(obj) {
      const ix = houseCount;
      const x = ix * spacing; // æ²¿ X è»¸æ’æˆä¸€æ¢è¡—
      const z = (ix % 2 === 0) ? -4 : 4; // å…©å´éŒ¯è½
      obj.position.set(x, 0, z);
      obj.traverse?.(n => { if (n.isMesh) { n.castShadow = true; n.receiveShadow = true; }});
      scene.add(obj);
      houseCount++;
      updateList();
    }

    function scaleAndGround(obj) {
      const box = new THREE.Box3().setFromObject(obj);
      const size = new THREE.Vector3();
      box.getSize(size);
      const maxDim = Math.max(size.x, size.y, size.z) || 1;
      const s = targetSize / maxDim;
      obj.scale.setScalar(s);
      // é‡æ–°ç½®ä¸­åˆ°åº•é¢
      box.setFromObject(obj);
      const center = new THREE.Vector3();
      box.getCenter(center);
      const yMin = box.min.y;
      obj.position.add(new THREE.Vector3(-center.x, -yMin, -center.z));
    }

    function addGLBFromURL(url, name = 'æ¨¡å‹') {
      gltfLoader.load(url, (gltf) => {
        const obj = gltf.scene || gltf.scenes?.[0];
        scaleAndGround(obj);
        models.push({ name, obj });
        placeModel(obj);
      }, undefined, (err) => {
        console.error('GLB è¼‰å…¥å¤±æ•—ï¼š', err);
        alert('GLB è¼‰å…¥å¤±æ•—ï¼š' + (name || url));
      });
    }

    function addOBJFromURL(url, name='æ¨¡å‹') {
      objLoader.load(url, (obj) => {
        // è‹¥ OBJ æ²’æè³ªï¼Œçµ¦å€‹é è¨­æè³ª
        obj.traverse(n => { if (n.isMesh && !Array.isArray(n.material)) { n.material = n.material || new THREE.MeshStandardMaterial({ color: 0xcccccc }); }});
        scaleAndGround(obj);
        models.push({ name, obj });
        placeModel(obj);
      }, undefined, (err) => {
        console.error('OBJ è¼‰å…¥å¤±æ•—ï¼š', err);
        alert('OBJ è¼‰å…¥å¤±æ•—ï¼š' + (name || url));
      });
    }

    function addSTLFromURL(url, name='æ¨¡å‹') {
      stlLoader.load(url, (geom) => {
        const mat = new THREE.MeshStandardMaterial({ color: 0xd1d5db, metalness: 0.1, roughness: 0.8 });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.castShadow = true; mesh.receiveShadow = true;
        const obj = new THREE.Group();
        obj.add(mesh);
        scaleAndGround(obj);
        models.push({ name, obj });
        placeModel(obj);
      }, undefined, (err) => {
        console.error('STL è¼‰å…¥å¤±æ•—ï¼š', err);
        alert('STL è¼‰å…¥å¤±æ•—ï¼š' + (name || url));
      });
    }

    function addFromFile(file) {
      const url = URL.createObjectURL(file);
      const name = file.name.replace(/\.(glb|gltf|obj|stl)$/i, '');
      if (/\.(glb|gltf)$/i.test(file.name)) return addGLBFromURL(url, name);
      if (/\.obj$/i.test(file.name)) return addOBJFromURL(url, name);
      if (/\.stl$/i.test(file.name)) return addSTLFromURL(url, name);
      alert('ä¸æ”¯æ´çš„æª”æ¡ˆæ ¼å¼ï¼š' + file.name);
    }

    // æ¸…å–® UI
    const listEl = document.getElementById('list');
    function updateList() {
      listEl.innerHTML = '';
      models.forEach((m, i) => {
        const row = document.createElement('div');
        row.className = 'item';
        row.innerHTML = `<span class="badge">#${i+1}</span> <span>${m.name}</span>`;
        listEl.appendChild(row);
      });
    }

    // ä¸Šå‚³/æ‹–æ”¾è™•ç†
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('file');

    // æ“´å……å¯æ¥å—æ ¼å¼
    fileInput.setAttribute('accept', '.glb,.gltf,.obj,.stl');

    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); fileInput.click(); }});
    fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

    function handleFiles(fileList) {
      const files = Array.from(fileList).filter(f => /\.(glb|gltf|obj|stl)$/i.test(f.name));
      if (!files.length) { alert('è«‹é¸æ“‡ .glb / .gltf / .obj / .stl æª”æ¡ˆ'); return; }
      files.forEach(addFromFile);
    }

    ['dragenter','dragover'].forEach(evt => {
      window.addEventListener(evt, (e) => { e.preventDefault(); dropzone.classList.add('dragover'); });
    });
    ;['dragleave','drop'].forEach(evt => {
      window.addEventListener(evt, (e) => { e.preventDefault(); dropzone.classList.remove('dragover'); });
    });
    window.addEventListener('drop', (e) => {
      const dt = e.dataTransfer;
      if (!dt?.files?.length) return;
      handleFiles(dt.files);
    });

    // æ§åˆ¶åˆ—
    document.getElementById('resetCam').addEventListener('click', () => {
      camera.position.set(24, 16, 34);
      controls.target.set(10, 0, 0);
      controls.update();
    });

    document.getElementById('clearAll').addEventListener('click', () => {
      models.forEach(m => scene.remove(m.obj));
      models.length = 0;
      houseCount = 0;
      updateList();
    });

    // è¦–çª—å°ºå¯¸è™•ç†
    function resizeRendererToDisplaySize() {
      const wrap = document.getElementById('canvas-wrap');
      const width = wrap.clientWidth;
      const height = wrap.clientHeight;
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }
      return needResize;
    }

    // å‹•ç•«è¿´åœˆ
    renderer.setAnimationLoop(() => {
      resizeRendererToDisplaySize();
      controls.update();
      renderer.render(scene, camera);
    });

    // --- é è¨­ç¤ºç¯„ï¼ˆå¯ç§»é™¤ï¼‰---
    // addGLBFromURL('https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/House/glTF-Binary/House.glb', 'ç¤ºç¯„æˆ¿å­');
  </script>
</body>
</html>
